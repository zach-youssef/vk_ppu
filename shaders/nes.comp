#version 450

struct Tile {
    uint data[4];
} tile;

struct TileSet {
    Tile tiles[256];
} tileSet;

struct NameTable {
    uint tileIndices[240];
    uint attributeTable[16];
} nameTable;

layout(std140, binding = 0) uniform readonly PPUMemory {
    TileSet tileSets[2];
    NameTable nameTables[4];
    uint padding0[960];
    uint backgroundPalettes[4];
    uint spritePalettes[4];
    uint padding1[56];
} memory;

layout(binding = 1, rgba8) uniform writeonly image2D frame;

const uvec3 COLORS[] = {
    uvec3(124, 124, 124),
    uvec3(0, 0, 252),
    uvec3(0, 0, 188),
    uvec3(68, 40, 188),
    uvec3(148, 0, 132),
    uvec3(168, 0, 32),
    uvec3(168, 16, 0),
    uvec3(136, 20, 0),
    uvec3(80, 48, 0),
    uvec3(0, 120, 0),
    uvec3(0, 104, 0),
    uvec3(0, 88, 0),
    uvec3(0, 64, 88),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(188, 188, 188),
    uvec3(0, 120, 248),
    uvec3(0, 88, 248),
    uvec3(104, 68, 252),
    uvec3(216, 0, 204),
    uvec3(228, 0, 88),
    uvec3(248, 56, 0),
    uvec3(228, 92, 16),
    uvec3(172, 124, 0),
    uvec3(0, 184, 0),
    uvec3(0, 168, 0),
    uvec3(0, 168, 68),
    uvec3(0, 136, 136),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(248, 248, 248),
    uvec3(60, 188, 252),
    uvec3(104, 136, 252),
    uvec3(152, 120, 248),
    uvec3(248, 120, 248),
    uvec3(248, 88, 152),
    uvec3(248, 120, 88),
    uvec3(252, 160, 68),
    uvec3(248, 184, 0),
    uvec3(184, 248, 24),
    uvec3(88, 216, 84),
    uvec3(88, 248, 152),
    uvec3(0, 232, 216),
    uvec3(120, 120, 120),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(252, 252, 252),
    uvec3(164, 228, 252),
    uvec3(184, 184, 248),
    uvec3(216, 184, 248),
    uvec3(248, 184, 248),
    uvec3(248, 164, 192),
    uvec3(240, 208, 176),
    uvec3(252, 224, 168),
    uvec3(248, 216, 120),
    uvec3(216, 248, 120),
    uvec3(184, 248, 184),
    uvec3(184, 248, 216),
    uvec3(0, 252, 252),
    uvec3(248, 216, 248),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0)
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

uint unpackByteFromUint(uint packed, uint byteIdx) {
    // Data is stored like
    // 00000000 111111111 22222222 33333333
    uint shiftDistance = (8 *  (3 - byteIdx));
    uint mask = 0xFF << shiftDistance;
    return (packed & mask) >> shiftDistance;
}

uint unpack2BitsFromByte(uint packed, uint byteIdx) {
    // Data is stored line
    // 00 11 22 33
    uint shiftDistance = (2 * (3 - byteIdx));
    uint mask = 0x03 << shiftDistance;
    return (packed & mask) >> shiftDistance;
}

void main() {
    uint x = uint(gl_LocalInvocationID.x);
    uint y = uint(gl_GlobalInvocationID.y);

    // Fetch background tile
    uint tileX = uint(x / 8);
    uint tileY = uint(y / 8);
    uint tileLocation = tileY * 30 + tileX;
    uint unpackedTileIdx = memory.nameTables[0].tileIndices[tileLocation / 4];
    uint tileIdx = unpackByteFromUint(unpackedTileIdx, tileLocation % 4);

    // Fetch pallette idx from attribute table
    // https://www.nesdev.org/wiki/PPU_attribute_tables
    uint attributeTableRowIdx = uint(y / 8);
    uint attributeTableColIdx = uint(x / 8);
    uint attributeTableHalfRow = memory.nameTables[0].attributeTable[(attributeTableRowIdx * 2) + uint(attributeTableColIdx / 4)];
    uint attributeByte = unpackByteFromUint(attributeTableHalfRow, attributeTableColIdx % 4);
    uint indexInAttributeByte = (uint(y / 16) % 2) * 2 + uint((x / 16) * 2);
    uint palletteIdx = unpack2BitsFromByte(attributeByte, indexInAttributeByte);
    uint pallete = memory.backgroundPalettes[palletteIdx];

    // Fetch pixel value for tile
    Tile tile = memory.tileSets[0].tiles[tileIdx];
    uint xIntoTile = x % 8;
    uint yIntoTile = y % 8;
    uint tile2RowChunk = tile.data[uint(yIntoTile / 2)];
    uint tileHalfRowChunk = unpackByteFromUint(tile2RowChunk, uint(yIntoTile % 2) * 2 + uint(xIntoTile / 4));
    uint indexIntoPalette = unpack2BitsFromByte(tileHalfRowChunk, xIntoTile % 4);

    //  Store output color
    uint color = unpackByteFromUint(pallete, indexIntoPalette);
    imageStore(frame, ivec2(x, y), vec4(vec3(COLORS[color]) / 255.0, 1.f));
}