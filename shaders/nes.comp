#version 450

#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

struct Tile {
    uint8_t plane0[8];
    uint8_t plane1[8];
} tile;

struct TileSet {
    Tile tiles[256];
} tileSet;

struct NameTable {
    uint8_t tileIndices[960];
    uint8_t attributeTable[64];
} nameTable;

struct Palette {
    uint8_t data[4];
} palette;

layout(std430, binding = 0) uniform readonly PPUMemory {
    TileSet tileSets[2];
    NameTable nameTables[4];
    uint8_t padding0[3840];
    Palette backgroundPalettes[4];
    Palette spritePalettes[4];
    uint8_t padding1[224];
} memory;

struct Sprite {
    uint8_t y;
    uint8_t tileIndex;
    uint8_t attr;
    uint8_t x;
} sprite;

layout(std430, binding = 1) uniform readonly OAM {
    Sprite sprites[4];
} oam;

layout(binding = 2, rgba8) uniform writeonly image2D frame;

const uvec3 COLORS[] = {
    uvec3(124, 124, 124),
    uvec3(0, 0, 252),
    uvec3(0, 0, 188),
    uvec3(68, 40, 188),
    uvec3(148, 0, 132),
    uvec3(168, 0, 32),
    uvec3(168, 16, 0),
    uvec3(136, 20, 0),
    uvec3(80, 48, 0),
    uvec3(0, 120, 0),
    uvec3(0, 104, 0),
    uvec3(0, 88, 0),
    uvec3(0, 64, 88),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(188, 188, 188),
    uvec3(0, 120, 248),
    uvec3(0, 88, 248),
    uvec3(104, 68, 252),
    uvec3(216, 0, 204),
    uvec3(228, 0, 88),
    uvec3(248, 56, 0),
    uvec3(228, 92, 16),
    uvec3(172, 124, 0),
    uvec3(0, 184, 0),
    uvec3(0, 168, 0),
    uvec3(0, 168, 68),
    uvec3(0, 136, 136),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(248, 248, 248),
    uvec3(60, 188, 252),
    uvec3(104, 136, 252),
    uvec3(152, 120, 248),
    uvec3(248, 120, 248),
    uvec3(248, 88, 152),
    uvec3(248, 120, 88),
    uvec3(252, 160, 68),
    uvec3(248, 184, 0),
    uvec3(184, 248, 24),
    uvec3(88, 216, 84),
    uvec3(88, 248, 152),
    uvec3(0, 232, 216),
    uvec3(120, 120, 120),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(252, 252, 252),
    uvec3(164, 228, 252),
    uvec3(184, 184, 248),
    uvec3(216, 184, 248),
    uvec3(248, 184, 248),
    uvec3(248, 164, 192),
    uvec3(240, 208, 176),
    uvec3(252, 224, 168),
    uvec3(248, 216, 120),
    uvec3(216, 248, 120),
    uvec3(184, 248, 184),
    uvec3(184, 248, 216),
    uvec3(0, 252, 252),
    uvec3(248, 216, 248),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0)
};

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

uint unpack2BitsFromByte(uint8_t packed, uint byteIdx) {
    // Assumes data is stored like
    // 33221100
    uint shiftDistance = (2 * byteIdx);
    uint mask = 0x03 << shiftDistance;
    return (packed & mask) >> shiftDistance;
}

uint unpackBitFromByte(uint8_t packed, uint byteIdx) {
    // Assumes data is stored like
    // 01234567
    uint shiftDistance = 7 - byteIdx;
    uint mask = 0x1 << shiftDistance;
    return (packed & mask) >> shiftDistance;
}

void main() {
    uint x = uint(gl_LocalInvocationID.x);
    uint y = uint(gl_GlobalInvocationID.y);

    // TEST - for SMB3 Home Screen, swap name tables
    uint nameTableIdx = y < 192 ? 0 : 2;
    uint patternTableIdx = 0;

    // Fetch background tile
    uint tileX = uint(x / 8);
    uint tileY = uint(y / 8);
    uint tileLocation = tileY * 32 + tileX;
    uint tileIdx = memory.nameTables[nameTableIdx].tileIndices[tileLocation];

    // Fetch pallette idx from attribute table
    // https://www.nesdev.org/wiki/PPU_attribute_tables
    uint attributeTableRowIdx = uint(tileY / 4);
    uint attributeTableColIdx = uint(tileX / 4);
    uint attributeLocation = attributeTableRowIdx * 8 + attributeTableColIdx;
    uint8_t attributeByte = memory.nameTables[nameTableIdx].attributeTable[attributeLocation];
    uint indexInAttributeByte = (uint(y / 16) % 2) * 2 + uint((x / 16) % 2);
    uint palletteIdx = unpack2BitsFromByte(attributeByte, indexInAttributeByte);
    Palette pallete = memory.backgroundPalettes[palletteIdx];

    // Fetch pixel value for tile
    // https://www.nesdev.org/wiki/PPU_pattern_tables
    Tile tile = memory.tileSets[patternTableIdx].tiles[tileIdx];
    uint xIntoTile = x % 8;
    uint yIntoTile = y % 8;
    uint lowBit = unpackBitFromByte(tile.plane0[yIntoTile], xIntoTile);
    uint highBit = unpackBitFromByte(tile.plane1[yIntoTile], xIntoTile);
    uint indexIntoPalette = (highBit << 1) | lowBit;

    //  Store output color
    uint8_t colorIdx = pallete.data[indexIntoPalette];
    imageStore(frame, ivec2(x, y), vec4(vec3(COLORS[colorIdx]) / 255.0, 1.f));
}