#version 450

#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

// Memory Layout Struct Definitions ----------------------------------

struct Tile {
    uint8_t plane0[8];
    uint8_t plane1[8];
} tile;

struct TileSet {
    Tile tiles[256];
} tileSet;

struct NameTable {
    uint8_t tileIndices[960];
    uint8_t attributeTable[64];
} nameTable;

struct Palette {
    uint8_t data[4];
} palette;

struct Sprite {
    uint8_t y;
    uint8_t tileIndex;
    uint8_t attr;
    uint8_t x;
} sprite;

// -------------------------------------------------------------------
// Descriptor Layout -------------------------------------------------
// -------------------------------------------------------------------

layout(std430, binding = 0) uniform readonly PPUMemory {
    TileSet tileSets[2];
    NameTable nameTables[4];
    uint8_t padding0[3840];
    Palette backgroundPalettes[4];
    Palette spritePalettes[4];
    uint8_t padding1[224];
} memory;

layout(std430, binding = 1) uniform readonly OAM {
    Sprite sprites[64];
} oam;

// Inspired by but not matching what the NES does
layout(std430, binding = 2) uniform readonly Control {
    uint16_t xScroll;
    uint16_t yScroll;
    uint8_t spriteHeight;
    uint8_t backgroundTileset;
    uint8_t spriteTileset;
    uint8_t nametableStart;
    // Align to 16 bytes for compatibility
    uint8_t padding[8]; 
} control;

layout(binding = 3, rgba8) uniform writeonly image2D frame;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// -------------------------------------------------------------------
// Constants ---------------------------------------------------------
// -------------------------------------------------------------------

#define SPR_ATTR_V_FLIP_MASK 1 << 7
#define SPR_ATTR_H_FLIP_MASK 1 << 6
#define SPR_ATTR_PRIORITY_MASK 1 << 5
#define SPR_ATTR_PALETTE_MASK 3

const uvec3 COLORS[] = {
    uvec3(124, 124, 124),
    uvec3(0, 0, 252),
    uvec3(0, 0, 188),
    uvec3(68, 40, 188),
    uvec3(148, 0, 132),
    uvec3(168, 0, 32),
    uvec3(168, 16, 0),
    uvec3(136, 20, 0),
    uvec3(80, 48, 0),
    uvec3(0, 120, 0),
    uvec3(0, 104, 0),
    uvec3(0, 88, 0),
    uvec3(0, 64, 88),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(188, 188, 188),
    uvec3(0, 120, 248),
    uvec3(0, 88, 248),
    uvec3(104, 68, 252),
    uvec3(216, 0, 204),
    uvec3(228, 0, 88),
    uvec3(248, 56, 0),
    uvec3(228, 92, 16),
    uvec3(172, 124, 0),
    uvec3(0, 184, 0),
    uvec3(0, 168, 0),
    uvec3(0, 168, 68),
    uvec3(0, 136, 136),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(248, 248, 248),
    uvec3(60, 188, 252),
    uvec3(104, 136, 252),
    uvec3(152, 120, 248),
    uvec3(248, 120, 248),
    uvec3(248, 88, 152),
    uvec3(248, 120, 88),
    uvec3(252, 160, 68),
    uvec3(248, 184, 0),
    uvec3(184, 248, 24),
    uvec3(88, 216, 84),
    uvec3(88, 248, 152),
    uvec3(0, 232, 216),
    uvec3(120, 120, 120),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0),
    uvec3(252, 252, 252),
    uvec3(164, 228, 252),
    uvec3(184, 184, 248),
    uvec3(216, 184, 248),
    uvec3(248, 184, 248),
    uvec3(248, 164, 192),
    uvec3(240, 208, 176),
    uvec3(252, 224, 168),
    uvec3(248, 216, 120),
    uvec3(216, 248, 120),
    uvec3(184, 248, 184),
    uvec3(184, 248, 216),
    uvec3(0, 252, 252),
    uvec3(248, 216, 248),
    uvec3(0, 0, 0),
    uvec3(0, 0, 0)
};

// -------------------------------------------------------------------
// Unpack Helpers ----------------------------------------------------
// -------------------------------------------------------------------

uint unpack2BitsFromByte(uint8_t packed, uint byteIdx) {
    // Assumes data is stored like
    // 33221100
    uint shiftDistance = (2 * byteIdx);
    uint mask = 0x03 << shiftDistance;
    return (packed & mask) >> shiftDistance;
}

uint unpackBitFromByte(uint8_t packed, uint byteIdx) {
    // Assumes data is stored like
    // 01234567
    uint shiftDistance = 7 - byteIdx;
    uint mask = 0x1 << shiftDistance;
    return (packed & mask) >> shiftDistance;
}

uint sampleTile(Tile tile, uint x, uint y) {
    uint xIntoTile = x % 8;
    uint yIntoTile = y % 8;
    uint lowBit = unpackBitFromByte(tile.plane0[yIntoTile], xIntoTile);
    uint highBit = unpackBitFromByte(tile.plane1[yIntoTile], xIntoTile);
    return (highBit << 1) | lowBit;
}

// -------------------------------------------------------------------
// Sprite Helpers ----------------------------------------------------
// -------------------------------------------------------------------
 
bool spriteOnScaline(Sprite sprite, uint y) {
    // Assuming 8x16 sprites
    return y >= sprite.y && y < sprite.y + 16;
}

bool spriteOnColumn(Sprite sprite, uint x) {
    return x >= sprite.x && x < sprite.x + 8;
}

// -------------------------------------------------------------------
// Sprite Evaluation -------------------------------------------------
// -------------------------------------------------------------------
 
// Group memory for evaluating sprites for the current scanline
shared Sprite[64] scanlineSprites;
shared uint[64] workIndices;

// When comparing two sprites, if both are on the scanline, select
// based on index
#define REDUCTION_STEP(stride)                                              \
    if (x < stride) {                                                       \
        Sprite s1 = scanlineSprites[x];                                     \
        Sprite s2 = scanlineSprites[x + stride];                            \
        bool useIndexCheck = spriteOnScaline(s1, y)                         \
                             == spriteOnScaline(s2, y);                     \
        bool select = useIndexCheck                                         \
            ? workIndices[x] > workIndices[x + stride]                      \
            : spriteOnScaline(s1, y);                                       \
        scanlineSprites[x] = select ? s1 : s2;                              \
        workIndices[x] = select ? workIndices[x] : workIndices[x + stride]; \
    }                                                                       \
    groupMemoryBarrier();                                                   \


void reduceScanlineSprites(uint x, uint y) {
    // Initialize reduction
    if (x < 64) {
        scanlineSprites[x] = oam.sprites[x];
        // Sprites in OAM have their y coordinates shifted by 1 as a 
        // real NES has sprite evaluation delayed by 1 scanline 
        // (see https://www.nesdev.org/wiki/PPU_OAM#Byte_0_-_Y_position)
        scanlineSprites[x].y += uint8_t(1);
        workIndices[x] = x;
    }
    groupMemoryBarrier();

    // Perform reduction
    REDUCTION_STEP(32)
    REDUCTION_STEP(16)
    REDUCTION_STEP(8)
}

// -------------------------------------------------------------------
// Sprite Processing Loop --------------------------------------------
// -------------------------------------------------------------------

#define PROCESS_SPRITE(spriteIdx)                                                       \
    sprite = scanlineSprites[spriteIdx];                                                \
    /* Grab the tile for the sprite */                                                  \
    yFlip = (sprite.attr & SPR_ATTR_V_FLIP_MASK) >> 7;                                  \
    spriteTile = memory.tileSets[sprite.tileIndex & 0x1]                                \
                            .tiles[(sprite.tileIndex & 0xFE)                            \
                                    + ((y - sprite.y > 7)                               \
                                        ? 1 - yFlip                                     \
                                        : yFlip)];                                      \
    /* Sample the tile */                                                               \
    xIntoTile = x - sprite.x;                                                           \
    xIntoTile = ((sprite.attr & SPR_ATTR_H_FLIP_MASK) != 0)? 7 - xIntoTile : xIntoTile; \
    yIntoTile = y - sprite.y;                                                           \
    yIntoTile = ((sprite.attr & SPR_ATTR_V_FLIP_MASK) != 0)? 7 - yIntoTile : yIntoTile; \
    tileValue = sampleTile(spriteTile, xIntoTile, yIntoTile);                           \
                                                                                        \
    /* Clear out value if this sprite is out of range */                                \
    tileValue *= spriteOnScaline(sprite, y)? 1 : 0;                                     \
    tileValue *= spriteOnColumn(sprite, x)? 1 : 0;                                      \
                                                                                        \
    /* We choose this sprite if it has a nonzero value */                               \
    spriteIndexIntoPalette = tileValue > 0? tileValue : spriteIndexIntoPalette;         \
    spritePriority = tileValue > 0                                                      \
        ? (sprite.attr & SPR_ATTR_PRIORITY_MASK) == 0                                   \
        : spritePriority;                                                               \
    spritePaletteIndex = tileValue > 0                                                  \
        ? sprite.attr & SPR_ATTR_PALETTE_MASK                                           \
        : spritePaletteIndex;                                                           \

// -------------------------------------------------------------------
// Main Shader -------------------------------------------------------
// -------------------------------------------------------------------

void main() {
    uint x = uint(gl_LocalInvocationID.x);
    uint y = uint(gl_GlobalInvocationID.y);

    // Reduce OAM to find the up to 8 sprites relevant to this frame
    reduceScanlineSprites(x, y);

    // TEST - for SMB3 Home Screen, swap name tables after
    // scanline 192
    uint nameTableIdx = y < 192 ? 0 : 2;
    uint patternTableIdx = 0;

    // Fetch background tile
    uint tileX = uint(x / 8);
    uint tileY = uint(y / 8);
    uint tileLocation = tileY * 32 + tileX;
    uint tileIdx = memory.nameTables[nameTableIdx].tileIndices[tileLocation];

    // Fetch pallette idx from attribute table
    // https://www.nesdev.org/wiki/PPU_attribute_tables
    uint attributeTableRowIdx = uint(tileY / 4);
    uint attributeTableColIdx = uint(tileX / 4);
    uint attributeLocation = attributeTableRowIdx * 8 + attributeTableColIdx;
    uint8_t attributeByte = memory.nameTables[nameTableIdx].attributeTable[attributeLocation];
    uint indexInAttributeByte = (uint(y / 16) % 2) * 2 + uint((x / 16) % 2);
    uint palletteIdx = unpack2BitsFromByte(attributeByte, indexInAttributeByte);
    Palette pallete = memory.backgroundPalettes[palletteIdx];

    // Fetch pixel value for tile
    // https://www.nesdev.org/wiki/PPU_pattern_tables
    Tile tile = memory.tileSets[patternTableIdx].tiles[tileIdx];
    uint indexIntoPalette = sampleTile(tile, x ,y);

    // Evaluate sprites (assuming 8x16)
    bool spritePriority = false;
    uint spriteIndexIntoPalette = 0;
    uint spritePaletteIndex = 0;
    // Declare 'loop' variables used inside unrolled step macro
    uint yFlip, xIntoTile, yIntoTile, tileValue;
    Sprite sprite;
    Tile spriteTile;
    // Loop through indices backwards for correct overlap
    PROCESS_SPRITE(7);
    PROCESS_SPRITE(6);
    PROCESS_SPRITE(5);
    PROCESS_SPRITE(4);
    PROCESS_SPRITE(3);
    PROCESS_SPRITE(2);
    PROCESS_SPRITE(1);
    PROCESS_SPRITE(0);

    // Render background or sprite based on priority
    bool drawSprite = indexIntoPalette == 0 || spritePriority;
    pallete = drawSprite? memory.spritePalettes[spritePaletteIndex] : pallete;
    indexIntoPalette = drawSprite ? spriteIndexIntoPalette : indexIntoPalette;

    //  Store output color
    uint8_t colorIdx = pallete.data[indexIntoPalette];
    imageStore(frame, ivec2(x, y), vec4(vec3(COLORS[colorIdx]) / 255.0, 1.f));
}